commit effc540808e630d1fad423d653c43737e99cc1b6
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Thu Oct 20 10:56:48 2011 -0400

    Fix oops on non-numa enabled systems
    
    Some systems aren't numa enabled, but still have devices that indicate they
    belong to numa node 0 (rather than -1 as they should).  Thats a kernel problem
    but we still shouldn't crash as a result (which we will when device get a NULL
    numa_node pointer as a result of trying to find non-existant node 0).  This
    patch fixes the crash by always returning the unspecified node pointer when numa
    is disabled
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>

diff --git a/classify.c b/classify.c
index 6a20480..bb34f04 100644
--- a/classify.c
+++ b/classify.c
@@ -281,7 +281,7 @@ struct irq_info *add_misc_irq(int irq)
 	new->irq = irq;
 	new->type = IRQ_TYPE_LEGACY;
 	new->class = IRQ_OTHER;
-	new->numa_node = get_numa_node(0);
+	new->numa_node = get_numa_node(-1);
 	interrupts_db = g_list_append(interrupts_db, new);
 	return new;
 }
diff --git a/irqbalance.h b/irqbalance.h
index a1b1e8a..73a0864 100644
--- a/irqbalance.h
+++ b/irqbalance.h
@@ -49,6 +49,7 @@ extern GList *numa_nodes;
 extern GList *packages;
 extern GList *cache_domains;
 extern GList *cpus;
+extern int numa_avail;
 
 enum hp_e {
 	HINT_POLICY_IGNORE,
diff --git a/numa.c b/numa.c
index 0d93091..9cbbfc0 100644
--- a/numa.c
+++ b/numa.c
@@ -162,6 +162,9 @@ struct topo_obj *get_numa_node(int nodeid)
 	struct topo_obj find;
 	GList *entry;
 
+	if (!numa_avail)
+		return &unspecified_node;
+
 	if (nodeid == -1)
 		return &unspecified_node;
 
