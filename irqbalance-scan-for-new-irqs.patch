From 1523a7830cb2670cb531a5fdea86885eaa648eaf Mon Sep 17 00:00:00 2001
From: Neil Horman <nhorman@tuxdriver.com>
Date: Mon, 2 Jul 2012 13:27:14 -0400
Subject: [PATCH] Make irqbalance scan for new irqs when it detects new irqs

Like cpu hotplug, irqbalance needs to rebuild its topo map and irq db when it
detects new irqs in the system.  This patch adds that ability

Resolves: http://code.google.com/p/irqbalance/issues/detail?id=32

Singed-off-by: Neil Horman <nhorman@tuxdriver.com>
---
 irqbalance.c     |  6 +++---
 irqbalance.h     |  2 +-
 procinterrupts.c | 14 ++++++++++++--
 3 files changed, 16 insertions(+), 6 deletions(-)

diff --git a/irqbalance.c b/irqbalance.c
index 1fcc367..7ef72af 100644
--- a/irqbalance.c
+++ b/irqbalance.c
@@ -46,7 +46,7 @@ int one_shot_mode;
 int debug_mode;
 int foreground_mode;
 int numa_avail;
-int need_cpu_rescan;
+int need_rescan;
 extern cpumask_t banned_cpus;
 enum hp_e hint_policy = HINT_POLICY_SUBSET;
 unsigned long power_thresh = ULONG_MAX;
@@ -301,8 +301,8 @@ int main(int argc, char** argv)
 		parse_proc_stat();
 
 		/* cope with cpu hotplug -- detected during /proc/interrupts parsing */
-		if (need_cpu_rescan) {
-			need_cpu_rescan = 0;
+		if (need_rescan) {
+			need_rescan = 0;
 			/* if there's a hotplug event we better turn off power mode for a bit until things settle */
 			power_mode = 0;
 			if (debug_mode)
diff --git a/irqbalance.h b/irqbalance.h
index b9b1f06..8ec7c23 100644
--- a/irqbalance.h
+++ b/irqbalance.h
@@ -64,7 +64,7 @@ enum hp_e {
 extern int debug_mode;
 extern int one_shot_mode;
 extern int power_mode;
-extern int need_cpu_rescan;
+extern int need_rescan;
 extern enum hp_e hint_policy;
 extern unsigned long long cycle_count;
 extern unsigned long power_thresh;
diff --git a/procinterrupts.c b/procinterrupts.c
index 8ffe30c..f1d6745 100644
--- a/procinterrupts.c
+++ b/procinterrupts.c
@@ -83,8 +83,18 @@ void parse_proc_interrupts(void)
 		c++;
 		number = strtoul(line, NULL, 10);
 		info = get_irq_info(number);
-		if (!info)
+		if (!info) {
+			/*
+ 			 * If this is our 0th pass through this routine
+ 			 * this is an irq that wasn't reported in sysfs
+ 			 * and we should just add it.  If we've been running
+ 			 * a while then this irq just appeared and its time  
+ 			 * to rescan our irqs
+ 			 */
+			if (cycle_count)
+				need_rescan = 1;
 			info = add_misc_irq(number);
+		}
 
 		count = 0;
 		cpunr = 0;
@@ -100,7 +110,7 @@ void parse_proc_interrupts(void)
 			cpunr++;
 		}
 		if (cpunr != core_count) 
-			need_cpu_rescan = 1;
+			need_rescan = 1;
 
 		info->last_irq_count = info->irq_count;		
 		info->irq_count = count;
-- 
1.7.11.4

